{
  "version": "1.0.0",
  "metadata": {
    "path": "/Users/stephaniedover/projects/code_conventions_finder",
    "detected_languages": [
      "node",
      "python"
    ],
    "total_files_scanned": 120
  },
  "rules": [
    {
      "id": "node.conventions.framework",
      "category": "api",
      "title": "Uses Express.js",
      "description": "Web application built with Express.js. Found 1 imports.",
      "confidence": 0.73,
      "language": "node",
      "evidence": [
        {
          "file_path": "tests/fixtures/node_typescript.ts",
          "line_start": 1,
          "line_end": 7,
          "excerpt": "/**\n * Example TypeScript file demonstrating conventions.\n */\nimport { Request, Response, NextFunction } from 'express';\n\ninterface User {\n    id: number;"
        }
      ],
      "stats": {
        "framework_counts": {
          "express": 1
        },
        "primary_framework": "express"
      }
    },
    {
      "id": "generic.conventions.repo_layout",
      "category": "structure",
      "title": "Standard repository layout",
      "description": "Repository has standard directories: src (source code), tests (tests)",
      "confidence": 0.6,
      "language": "generic",
      "evidence": [],
      "stats": {
        "found_directories": [
          "src",
          "tests"
        ]
      }
    },
    {
      "id": "python.conventions.typing_coverage",
      "category": "typing",
      "title": "High type annotation coverage",
      "description": "Type annotations are commonly used in this codebase. 199/201 functions (99%) have at least one type annotation.",
      "confidence": 0.95,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 46,
          "line_end": 56,
          "excerpt": "\n\nclass PluginLoader:\n    \"\"\"Loads and registers plugins from Python files.\"\"\"\n\n    def __init__(self, progress_callback: Optional[Callable[[str], None]] = None):\n        \"\"\"Initialize the plugin loader.\n\n        Args:\n            progress_callback: Optional callback for progress messages\n        \"\"\""
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 60,
          "line_end": 70,
          "excerpt": "    def _log(self, message: str) -> None:\n        \"\"\"Log a message via callback if available.\"\"\"\n        if self.progress_callback:\n            self.progress_callback(message)\n\n    def load_from_path(self, path: str) -> dict[str, Any]:\n        \"\"\"Load a plugin from a Python file path.\n\n        Args:\n            path: Path to the plugin Python file\n"
        },
        {
          "file_path": "src/conventions/detectors/base.py",
          "line_start": 53,
          "line_end": 63,
          "excerpt": "    # Override in subclasses\n    name: str = \"base\"\n    description: str = \"Base detector\"\n    languages: set[str] = set()  # Empty means language-agnostic\n\n    def __init__(self):\n        pass\n\n    def should_run(self, ctx: DetectorContext) -> bool:\n        \"\"\"Check if this detector should run given the context.\"\"\"\n        if not self.languages:"
        },
        {
          "file_path": "src/conventions/detectors/python/caching.py",
          "line_start": 97,
          "line_end": 107,
          "excerpt": "            return result\n\n        method_names = [m[\"name\"] for m in caching_methods.values()]\n\n        # Determine primary caching method\n        def get_count(key):\n            m = caching_methods[key]\n            return m.get(\"count\", 0) + m.get(\"import_count\", 0)\n\n        primary = max(caching_methods, key=get_count)\n"
        }
      ],
      "stats": {
        "total_functions": 201,
        "annotated_functions": 199,
        "fully_annotated_functions": 45,
        "any_annotation_coverage": 0.99,
        "full_annotation_coverage": 0.224
      }
    },
    {
      "id": "python.conventions.docstrings",
      "category": "documentation",
      "title": "High docstring coverage",
      "description": "Most public functions have docstrings. Functions: 192/201 (96%). Classes: 106/111.",
      "confidence": 0.8865671641791044,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 46,
          "line_end": 56,
          "excerpt": "\n\nclass PluginLoader:\n    \"\"\"Loads and registers plugins from Python files.\"\"\"\n\n    def __init__(self, progress_callback: Optional[Callable[[str], None]] = None):\n        \"\"\"Initialize the plugin loader.\n\n        Args:\n            progress_callback: Optional callback for progress messages\n        \"\"\""
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 60,
          "line_end": 70,
          "excerpt": "    def _log(self, message: str) -> None:\n        \"\"\"Log a message via callback if available.\"\"\"\n        if self.progress_callback:\n            self.progress_callback(message)\n\n    def load_from_path(self, path: str) -> dict[str, Any]:\n        \"\"\"Load a plugin from a Python file path.\n\n        Args:\n            path: Path to the plugin Python file\n"
        },
        {
          "file_path": "src/conventions/scan.py",
          "line_start": 28,
          "line_end": 34,
          "excerpt": "    \"\"\"\n    from .detectors.orchestrator import run_detectors\n\n    def progress(msg: str) -> None:\n        if verbose:\n            print(f\"  {msg}\")\n"
        },
        {
          "file_path": "src/conventions/detectors/base.py",
          "line_start": 55,
          "line_end": 61,
          "excerpt": "    description: str = \"Base detector\"\n    languages: set[str] = set()  # Empty means language-agnostic\n\n    def __init__(self):\n        pass\n\n    def should_run(self, ctx: DetectorContext) -> bool:"
        }
      ],
      "stats": {
        "total_public_functions": 201,
        "documented_functions": 192,
        "function_doc_ratio": 0.955,
        "total_classes": 111,
        "documented_classes": 106,
        "class_doc_ratio": 0.955
      }
    },
    {
      "id": "python.conventions.docstring_style",
      "category": "documentation",
      "title": "Google style docstrings",
      "description": "Docstrings follow Google style. 26/26 docstrings use this style.",
      "confidence": 0.8999999999999999,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 43,
          "line_end": 59,
          "excerpt": "class PluginError(Exception):\n    \"\"\"Error loading or validating a plugin.\"\"\"\n    pass\n\n\nclass PluginLoader:\n    \"\"\"Loads and registers plugins from Python files.\"\"\"\n\n    def __init__(self, progress_callback: Optional[Callable[[str], None]] = None):\n        \"\"\"Initialize the plugin loader.\n\n        Args:\n            progress_callback: Optional callback for progress messages\n        \"\"\"\n        self.progress_callback = progress_callback\n        self.loaded_plugins: list[str] = []\n"
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 57,
          "line_end": 73,
          "excerpt": "        self.progress_callback = progress_callback\n        self.loaded_plugins: list[str] = []\n\n    def _log(self, message: str) -> None:\n        \"\"\"Log a message via callback if available.\"\"\"\n        if self.progress_callback:\n            self.progress_callback(message)\n\n    def load_from_path(self, path: str) -> dict[str, Any]:\n        \"\"\"Load a plugin from a Python file path.\n\n        Args:\n            path: Path to the plugin Python file\n\n        Returns:\n            Dictionary with loaded detectors and rating rules\n"
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 136,
          "line_end": 152,
          "excerpt": "                        \"Must be a RatingRule instance.\"\n                    )\n                result[\"rating_rules\"][rule_id] = rule\n                self._log(f\"  Found rating rule: {rule_id}\")\n\n        self.loaded_plugins.append(str(plugin_path))\n        return result\n\n    def register_detectors(self, detectors: list[Type[BaseDetector]]) -> None:\n        \"\"\"Register detector classes with the registry.\n\n        Args:\n            detectors: List of detector classes to register\n        \"\"\"\n        for detector_class in detectors:\n            DetectorRegistry.register(detector_class)\n            self._log(f\"Registered detector: {detector_class.name}\")"
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 146,
          "line_end": 162,
          "excerpt": "\n        Args:\n            detectors: List of detector classes to register\n        \"\"\"\n        for detector_class in detectors:\n            DetectorRegistry.register(detector_class)\n            self._log(f\"Registered detector: {detector_class.name}\")\n\n    def merge_rating_rules(self, rules: dict[str, RatingRule]) -> None:\n        \"\"\"Merge rating rules into the global registry.\n\n        Args:\n            rules: Dictionary of rule_id -> RatingRule\n        \"\"\"\n        for rule_id, rule in rules.items():\n            if rule_id in RATING_RULES:\n                self._log(f\"Warning: Overriding existing rating rule: {rule_id}\")"
        },
        {
          "file_path": "src/conventions/plugins.py",
          "line_start": 158,
          "line_end": 174,
          "excerpt": "            rules: Dictionary of rule_id -> RatingRule\n        \"\"\"\n        for rule_id, rule in rules.items():\n            if rule_id in RATING_RULES:\n                self._log(f\"Warning: Overriding existing rating rule: {rule_id}\")\n            RATING_RULES[rule_id] = rule\n            self._log(f\"Registered rating rule: {rule_id}\")\n\n    def load_and_register(self, path: str) -> None:\n        \"\"\"Load a plugin and register all its components.\n\n        Args:\n            path: Path to the plugin Python file\n        \"\"\"\n        result = self.load_from_path(path)\n        self.register_detectors(result[\"detectors\"])\n        self.merge_rating_rules(result[\"rating_rules\"])"
        }
      ],
      "stats": {
        "style_counts": {
          "google": 26
        },
        "primary_style": "google",
        "primary_ratio": 1.0
      }
    },
    {
      "id": "python.conventions.naming",
      "category": "style",
      "title": "PEP 8 snake_case naming",
      "description": "Function names follow PEP 8 snake_case convention. 193/193 functions use snake_case. Found 16 module-level constants.",
      "confidence": 0.95,
      "language": "python",
      "evidence": [],
      "stats": {
        "snake_case_functions": 193,
        "camel_case_functions": 0,
        "snake_case_ratio": 1.0,
        "module_constants": 16
      }
    },
    {
      "id": "python.conventions.testing_framework",
      "category": "testing",
      "title": "pytest-based testing",
      "description": "Uses pytest as primary testing framework. Found 41 pytest usages.",
      "confidence": 0.95,
      "language": "python",
      "evidence": [
        {
          "file_path": "tests/conftest.py",
          "line_start": 6,
          "line_end": 12,
          "excerpt": "from pathlib import Path\nfrom typing import Any\n\nimport pytest\n\nfrom conventions.config import ConventionsConfig\nfrom conventions.detectors.base import DetectorContext"
        },
        {
          "file_path": "tests/unit/test_ratings.py",
          "line_start": 1,
          "line_end": 7,
          "excerpt": "\"\"\"Tests for rating rules and scoring.\"\"\"\nfrom __future__ import annotations\n\nimport pytest\n\nfrom conventions.ratings import (\n    DEFAULT_RATING_RULE,"
        },
        {
          "file_path": "tests/unit/test_config.py",
          "line_start": 4,
          "line_end": 10,
          "excerpt": "import json\nfrom pathlib import Path\n\nimport pytest\n\nfrom conventions.config import (\n    CONFIG_FILE_NAMES,"
        },
        {
          "file_path": "tests/unit/test_schemas.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "\nimport json\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom conventions.schemas import ("
        },
        {
          "file_path": "tests/integration/test_reports.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "\nfrom pathlib import Path\n\nimport pytest\n\nfrom conventions.report import (\n    generate_markdown_report,"
        }
      ],
      "stats": {
        "framework_counts": {
          "pytest": 41,
          "unittest_style": 37
        },
        "primary_framework": "pytest",
        "test_file_count": 18
      }
    },
    {
      "id": "python.conventions.testing_fixtures",
      "category": "testing",
      "title": "Centralized pytest fixtures in conftest.py",
      "description": "Uses pytest fixtures with 1 conftest.py file(s). Found 24 fixture definitions.",
      "confidence": 0.9,
      "language": "python",
      "evidence": [
        {
          "file_path": "tests/conftest.py",
          "line_start": 11,
          "line_end": 21,
          "excerpt": "from conventions.config import ConventionsConfig\nfrom conventions.detectors.base import DetectorContext\nfrom conventions.schemas import ConventionRule, ConventionsOutput, EvidenceSnippet, RepoMetadata\n\n\n@pytest.fixture\ndef tmp_repo(tmp_path: Path) -> Path:\n    \"\"\"Create a minimal repository structure for testing.\"\"\"\n    # Create basic structure\n    (tmp_path / \"src\").mkdir()\n    (tmp_path / \"tests\").mkdir()"
        },
        {
          "file_path": "tests/conftest.py",
          "line_start": 25,
          "line_end": 35,
          "excerpt": "    (tmp_path / \".gitignore\").write_text(\"*.pyc\\n__pycache__/\\n.venv/\\n\")\n\n    return tmp_path\n\n\n@pytest.fixture\ndef sample_repo(tmp_repo: Path) -> Path:\n    \"\"\"Create a sample repository with Python files for testing.\"\"\"\n    # Create Python files\n    typed_py = '''\"\"\"Typed module example.\"\"\"\nfrom typing import Optional, List"
        },
        {
          "file_path": "tests/conftest.py",
          "line_start": 129,
          "line_end": 139,
          "excerpt": "    (tmp_repo / \"tests\" / \"conftest.py\").write_text(conftest)\n\n    return tmp_repo\n\n\n@pytest.fixture\ndef node_sample_repo(tmp_repo: Path) -> Path:\n    \"\"\"Create a sample repository with TypeScript files for testing.\"\"\"\n    (tmp_repo / \"src\").mkdir(exist_ok=True)\n\n    ts_file = '''import { User } from './types';"
        },
        {
          "file_path": "tests/conftest.py",
          "line_start": 201,
          "line_end": 211,
          "excerpt": "    (tmp_repo / \"package.json\").write_text(package_json)\n\n    return tmp_repo\n\n\n@pytest.fixture\ndef detector_context(sample_repo: Path) -> DetectorContext:\n    \"\"\"Create a DetectorContext for testing detectors.\"\"\"\n    return DetectorContext(\n        repo_root=sample_repo,\n        selected_languages={\"python\"},"
        },
        {
          "file_path": "tests/conftest.py",
          "line_start": 212,
          "line_end": 222,
          "excerpt": "        max_files=100,\n        max_evidence_snippets=5,\n    )\n\n\n@pytest.fixture\ndef config_file(tmp_path: Path) -> Path:\n    \"\"\"Create a test .conventionsrc.json file.\"\"\"\n    config_data = {\n        \"languages\": [\"python\"],\n        \"max_files\": 500,"
        }
      ],
      "stats": {
        "fixture_count": 24,
        "conftest_count": 1,
        "async_fixture_count": 0
      }
    },
    {
      "id": "python.conventions.testing_mocking",
      "category": "testing",
      "title": "Uses unittest.mock for mocking",
      "description": "Exclusively uses unittest.mock. Found 2 usages.",
      "confidence": 0.6599999999999999,
      "language": "python",
      "evidence": [
        {
          "file_path": "tests/integration/test_cli.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "\nimport json\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nimport pytest\nfrom typer.testing import CliRunner"
        },
        {
          "file_path": "tests/fixtures/python_pytest.py",
          "line_start": 1,
          "line_end": 6,
          "excerpt": "\"\"\"Example pytest test file.\"\"\"\nimport pytest\nfrom unittest.mock import Mock, patch\n\n\n@pytest.fixture"
        }
      ],
      "stats": {
        "mock_library_counts": {
          "unittest_mock": 2
        },
        "primary_mock_library": "unittest_mock"
      }
    },
    {
      "id": "python.conventions.logging_library",
      "category": "logging",
      "title": "Uses Python standard logging",
      "description": "Exclusively uses Python standard logging for logging. Found 4 usages.",
      "confidence": 0.7799999999999999,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/detectors/go/__init__.py",
          "line_start": 7,
          "line_end": 13,
          "excerpt": "from .conventions import GoConventionsDetector\nfrom .documentation import GoDocumentationDetector\nfrom .testing import GoTestingDetector\nfrom .logging import GoLoggingDetector\nfrom .errors import GoErrorHandlingDetector\nfrom .security import GoSecurityDetector\nfrom .concurrency import GoConcurrencyDetector"
        },
        {
          "file_path": "src/conventions/detectors/python/__init__.py",
          "line_start": 6,
          "line_end": 12,
          "excerpt": "from .typing import PythonTypingConventionsDetector\nfrom .documentation import PythonDocstringNamingConventionsDetector\nfrom .testing import PythonTestingConventionsDetector\nfrom .logging import PythonLoggingConventionsDetector\nfrom .errors import PythonErrorConventionsDetector\nfrom .security import PythonSecurityConventionsDetector\nfrom .async_concurrency import PythonAsyncConventionsDetector"
        },
        {
          "file_path": "src/conventions/detectors/rust/__init__.py",
          "line_start": 14,
          "line_end": 20,
          "excerpt": "from .documentation import RustDocumentationDetector\nfrom .unsafe_code import RustUnsafeDetector\nfrom .macros import RustMacrosDetector\nfrom .logging import RustLoggingDetector\nfrom .database import RustDatabaseDetector\n\n__all__ = ["
        },
        {
          "file_path": "src/conventions/detectors/node/__init__.py",
          "line_start": 8,
          "line_end": 14,
          "excerpt": "from .typescript import NodeTypeScriptDetector\nfrom .documentation import NodeDocumentationDetector\nfrom .testing import NodeTestingDetector\nfrom .logging import NodeLoggingDetector\nfrom .errors import NodeErrorHandlingDetector\nfrom .security import NodeSecurityDetector\nfrom .async_patterns import NodeAsyncPatternsDetector"
        }
      ],
      "stats": {
        "library_counts": {
          "stdlib_logging": 4
        },
        "primary_library": "stdlib_logging",
        "primary_ratio": 1.0
      }
    },
    {
      "id": "python.conventions.exception_handlers",
      "category": "error_handling",
      "title": "Centralized exception handling",
      "description": "Exception handlers are centralized in a single module. Found 3 handlers in src/conventions/detectors/python/errors.py.",
      "confidence": 0.85,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/detectors/python/errors.py",
          "line_start": 31,
          "line_end": 41,
          "excerpt": "\n        # Detect custom exception taxonomy\n        self._detect_exception_taxonomy(ctx, index, result)\n\n        # Detect exception handler patterns\n        self._detect_exception_handlers(ctx, index, result)\n\n        return result\n\n    def _detect_http_exception_boundary(\n        self,"
        },
        {
          "file_path": "src/conventions/detectors/python/errors.py",
          "line_start": 208,
          "line_end": 218,
          "excerpt": "        exception_handler_decorators = []\n        exception_handler_calls = []\n\n        for rel_path, dec in index.get_all_decorators():\n            if \"exception_handler\" in dec.name.lower():\n                exception_handler_decorators.append((rel_path, dec.line, dec.name))\n\n        for rel_path, call in index.get_all_calls():\n            if \"add_exception_handler\" in call.name or \"exception_handler\" in call.name.lower():\n                exception_handler_calls.append((rel_path, call.line, call.name))\n"
        },
        {
          "file_path": "src/conventions/detectors/python/errors.py",
          "line_start": 212,
          "line_end": 222,
          "excerpt": "            if \"exception_handler\" in dec.name.lower():\n                exception_handler_decorators.append((rel_path, dec.line, dec.name))\n\n        for rel_path, call in index.get_all_calls():\n            if \"add_exception_handler\" in call.name or \"exception_handler\" in call.name.lower():\n                exception_handler_calls.append((rel_path, call.line, call.name))\n\n        total_handlers = len(exception_handler_decorators) + len(exception_handler_calls)\n\n        if total_handlers < 2:\n            return"
        }
      ],
      "stats": {
        "total_handlers": 3,
        "decorator_handlers": 0,
        "call_handlers": 3,
        "handler_files": [
          "src/conventions/detectors/python/errors.py"
        ]
      }
    },
    {
      "id": "python.conventions.schema_library",
      "category": "api",
      "title": "Primary schema library: dataclasses",
      "description": "Uses dataclasses as primary schema library (8/15 usages). Also uses: Pydantic.",
      "confidence": 0.6866666666666666,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/config.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "from __future__ import annotations\n\nimport json\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n"
        },
        {
          "file_path": "src/conventions/cache.py",
          "line_start": 8,
          "line_end": 14,
          "excerpt": "\nimport hashlib\nimport json\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Optional"
        },
        {
          "file_path": "src/conventions/ratings.py",
          "line_start": 2,
          "line_end": 8,
          "excerpt": "\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Callable\n\nfrom .schemas import ConventionRule"
        },
        {
          "file_path": "src/conventions/detectors/base.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Optional\n"
        },
        {
          "file_path": "src/conventions/detectors/go/index.py",
          "line_start": 3,
          "line_end": 9,
          "excerpt": "from __future__ import annotations\n\nimport re\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Optional\n"
        }
      ],
      "stats": {
        "library_counts": {
          "pydantic": 7,
          "dataclasses": 8
        },
        "primary_library": "dataclasses"
      }
    },
    {
      "id": "python.conventions.di_style",
      "category": "dependency_injection",
      "title": "Container-based dependency injection",
      "description": "Uses a DI container library for dependency management. Found 4 usages.",
      "confidence": 0.6799999999999999,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/detectors/go/__init__.py",
          "line_start": 15,
          "line_end": 25,
          "excerpt": "from .api import GoAPIDetector\nfrom .patterns import GoPatternsDetector\nfrom .modules import GoModulesDetector\nfrom .cli import GoCLIDetector\nfrom .migrations import GoMigrationsDetector\nfrom .di import GoDIDetector\nfrom .grpc import GoGRPCDetector\nfrom .codegen import GoCodegenDetector\n\n__all__ = [\n    \"GoIndex\","
        },
        {
          "file_path": "src/conventions/detectors/python/__init__.py",
          "line_start": 10,
          "line_end": 20,
          "excerpt": "from .errors import PythonErrorConventionsDetector\nfrom .security import PythonSecurityConventionsDetector\nfrom .async_concurrency import PythonAsyncConventionsDetector\nfrom .architecture import PythonLayeringConventionsDetector\nfrom .api_schema import PythonAPISchemaConventionsDetector\nfrom .di_patterns import PythonDIConventionsDetector\nfrom .db import PythonDBConventionsDetector\nfrom .observability import PythonObservabilityConventionsDetector\nfrom .resilience import PythonRetriesTimeoutsConventionsDetector\nfrom .tooling import PythonToolingDetector\nfrom .dependency_management import PythonDependencyManagementDetector"
        },
        {
          "file_path": "src/conventions/detectors/generic/__init__.py",
          "line_start": 4,
          "line_end": 14,
          "excerpt": "from .ci_cd import CICDDetector\nfrom .git_conventions import GitConventionsDetector\nfrom .dependency_updates import DependencyUpdatesDetector\nfrom .api_docs import APIDocumentationDetector\nfrom .containerization import ContainerizationDetector\nfrom .editor_config import EditorConfigDetector\n\n__all__ = [\n    \"GenericRepoLayoutDetector\",\n    \"CICDDetector\",\n    \"GitConventionsDetector\","
        },
        {
          "file_path": "src/conventions/detectors/generic/containerization.py",
          "line_start": 9,
          "line_end": 19,
          "excerpt": "from ..registry import DetectorRegistry\nfrom ...fs import read_file_safe\n\n\n@DetectorRegistry.register\nclass ContainerizationDetector(BaseDetector):\n    \"\"\"Detect containerization patterns.\"\"\"\n\n    name = \"generic_containerization\"\n    description = \"Detects Docker and container configuration patterns\"\n"
        }
      ],
      "stats": {
        "pattern_counts": {
          "container_di": 4
        },
        "dominant_pattern": "container_di",
        "depends_count": 0,
        "common_dependency_names": {}
      }
    },
    {
      "id": "python.conventions.correlation_ids",
      "category": "observability",
      "title": "Request/correlation ID propagation",
      "description": "Uses request or correlation IDs for tracing. Found 2 correlation ID references.",
      "confidence": 0.6,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/detectors/python/logging.py",
          "line_start": 144,
          "line_end": 150,
          "excerpt": "\n        # Common fields we're looking for\n        common_fields = {\n            \"user_id\", \"request_id\", \"trace_id\", \"correlation_id\",\n            \"session_id\", \"order_id\", \"customer_id\", \"transaction_id\",\n            \"action\", \"event\", \"status\", \"duration\", \"error\", \"exception\",\n            \"method\", \"path\", \"url\", \"ip\", \"user_agent\","
        },
        {
          "file_path": "src/conventions/detectors/python/observability.py",
          "line_start": 264,
          "line_end": 270,
          "excerpt": "\n        # Common correlation ID patterns\n        correlation_patterns = [\n            \"request_id\",\n            \"correlation_id\",\n            \"trace_id\",\n            \"x_request_id\","
        }
      ],
      "stats": {
        "correlation_id_references": 2,
        "uuid_generation_count": 0
      }
    },
    {
      "id": "python.conventions.linter",
      "category": "tooling",
      "title": "Linters: Ruff, mypy",
      "description": "Uses Ruff, mypy for code quality.",
      "confidence": 0.8999999999999999,
      "language": "python",
      "evidence": [],
      "stats": {
        "linters": [
          "ruff",
          "mypy"
        ],
        "primary_linter": "ruff",
        "linter_details": {
          "ruff": {
            "name": "Ruff",
            "config_file": "pyproject.toml",
            "features": [
              "custom rules",
              "ignores configured"
            ]
          },
          "mypy": {
            "name": "mypy",
            "config_file": "pyproject.toml"
          }
        }
      }
    },
    {
      "id": "python.conventions.import_sorting",
      "category": "tooling",
      "title": "Import sorting: Ruff (isort rules)",
      "description": "Uses Ruff (isort rules) for import organization.",
      "confidence": 0.9,
      "language": "python",
      "evidence": [],
      "stats": {
        "sorters": [
          "ruff"
        ],
        "primary_sorter": "ruff",
        "sorter_details": {
          "ruff": {
            "name": "Ruff (isort rules)",
            "config_file": "pyproject.toml"
          }
        }
      }
    },
    {
      "id": "python.conventions.cli_framework",
      "category": "cli",
      "title": "CLI framework: Typer",
      "description": "Uses Typer for CLI.",
      "confidence": 0.9,
      "language": "python",
      "evidence": [
        {
          "file_path": "tests/integration/test_cli.py",
          "line_start": 6,
          "line_end": 12,
          "excerpt": "from unittest.mock import patch\n\nimport pytest\nfrom typer.testing import CliRunner\n\nfrom conventions.cli import app\n"
        },
        {
          "file_path": "src/conventions/cli.py",
          "line_start": 5,
          "line_end": 11,
          "excerpt": "from pathlib import Path\nfrom typing import Optional\n\nimport typer\nfrom rich.console import Console\n\nfrom .config import ConventionsConfig, load_config"
        }
      ],
      "stats": {
        "frameworks": [
          "typer"
        ],
        "primary_framework": "typer",
        "framework_details": {
          "typer": {
            "name": "Typer",
            "import_count": 2
          }
        }
      }
    },
    {
      "id": "python.conventions.graphql",
      "category": "api",
      "title": "GraphQL: graphql-core",
      "description": "Uses graphql-core for GraphQL API. (low-level)",
      "confidence": 0.85,
      "language": "python",
      "evidence": [
        {
          "file_path": "src/conventions/detectors/python/__init__.py",
          "line_start": 21,
          "line_end": 27,
          "excerpt": "from .cli_patterns import PythonCLIPatternDetector\nfrom .background_tasks import PythonBackgroundTaskDetector\nfrom .caching import PythonCachingDetector\nfrom .graphql import PythonGraphQLDetector\n\n__all__ = [\n    \"PythonIndex\","
        }
      ],
      "stats": {
        "libraries": [
          "graphql_core"
        ],
        "primary_library": "graphql_core",
        "library_details": {
          "graphql_core": {
            "name": "graphql-core",
            "import_count": 1,
            "style": "low-level"
          }
        }
      }
    }
  ],
  "warnings": []
}